---
# ==============================================================================
# DIAGNOSTICS - Cluster state before this workload
# ==============================================================================
- name: "DIAG - Cluster state checkpoint"
  shell: |
    echo "=== NODE USAGE ==="
    oc adm top nodes 2>/dev/null || echo "Metrics not available"
    echo ""
    echo "=== PODS: Running=$(oc get pods -A --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l) Pending=$(oc get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l) Failed=$(oc get pods -A --field-selector=status.phase=Failed --no-headers 2>/dev/null | wc -l) Total=$(oc get pods -A --no-headers 2>/dev/null | wc -l) ==="
    echo ""
    echo "=== PENDING PODS ==="
    oc get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | head -10 || echo "None"
    echo ""
    echo "=== CSVs NOT SUCCEEDED ==="
    oc get csv -A --no-headers 2>/dev/null | grep -v Succeeded | head -10 || echo "All succeeded"
    echo ""
    echo "=== PENDING PVCs ==="
    oc get pvc -A --field-selector=status.phase!=Bound --no-headers 2>/dev/null | head -10 || echo "All bound"
  register: diag_pre_workload
  ignore_errors: true

- name: "DIAG - Display pre-workload state"
  debug:
    msg: "{{ diag_pre_workload.stdout_lines | default(['no output']) }}"
  when: diag_pre_workload is defined
  ignore_errors: true

# ==============================================================================
# WORKLOAD with post-failure diagnostics
# ==============================================================================
- name: Run workload with failure capture
  block:
    # Implement your Workload deployment tasks here
    - name: Set subscription extra config for nested kvm
      when: ocp4_workload_openshift_virtualization_enabled_nested_kvm | bool
      ansible.builtin.set_fact:
        _ocp4_workload_openshift_virtualization_extra_config:
          env:
          - name: KVM_EMULATION
            value: "true"

    - name: Install OpenShift Virtualization Operator
      ansible.builtin.include_role:
        name: install_operator
      vars:
        install_operator_action: install
        install_operator_name: kubevirt-hyperconverged
        install_operator_namespace: openshift-cnv
        install_operator_manage_namespaces:
        - openshift-cnv
        install_operator_channel: "{{ ocp4_workload_openshift_virtualization_channel }}"
        install_operator_catalog: redhat-operators
        install_operator_automatic_install_plan_approval: "{{ ocp4_workload_openshift_virtualization_automatic_install_plan_approval | default(true) }}"
        install_operator_starting_csv: "{{ ocp4_workload_openshift_virtualization_starting_csv }}"
        install_operator_catalogsource_setup: "{{ ocp4_workload_openshift_virtualization_use_catalog_snapshot | default(false) }}"
        install_operator_catalogsource_name: "{{ ocp4_workload_openshift_virtualization_catalogsource_name | default('') }}"
        install_operator_catalogsource_namespace: openshift-cnv
        install_operator_catalogsource_image: "{{ ocp4_workload_openshift_virtualization_catalog_snapshot_image | default('') }}"
        install_operator_catalogsource_image_tag: "{{ ocp4_workload_openshift_virtualization_catalog_snapshot_image_tag | default('') }}"
        install_operator_subscription_config: "{{ _ocp4_workload_openshift_virtualization_extra_config }}"

    - name: Deploy and configure HyperConverged
      when: ocp4_workload_openshift_virtualization_deploy_hyperconverged | bool
      block:
      - name: Create the HyperConverged instance
        kubernetes.core.k8s:
          state: present
          definition: "{{ lookup('template', 'hyperconverged.yaml.j2') }}"

      - name: Wait until HyperConverged is installed
        kubernetes.core.k8s_info:
          api_version: hco.kubevirt.io/v1beta1
          kind: HyperConverged
          name: kubevirt-hyperconverged
          namespace: openshift-cnv
          wait: true
          wait_sleep: 10
          wait_timeout: 1200
          wait_condition:
            reason: "ReconcileCompleted"
            type: "Available"
            status: "True"

      # For deployments on CNV with external Ceph use PVCs for boot image snapshots
      # HyperConverged must have been created with .spec.featureGates.enableCommonBootImageImport: false
      # See template for that logic
      - name: Set boot sources to use PVCs
        when: not ocp4_workload_openshift_virtualization_boot_sources_shapshot | bool
        block:
        - name: Get all available storage classes
          kubernetes.core.k8s_info:
            api_version: storage.k8s.io/v1
            kind: StorageClass
          register: r_storageclasses

        - name: Abort if no storage classes found
          when: r_storageclasses.resources | length == 0
          ansible.builtin.fail:
            msg: "No storage classes found. Can not continue."

        - name: Find default storage class
          ansible.builtin.set_fact:
            _ocp4_workload_openshift_virtualization_default_storage_class: "{{ default_sc[0] }}"
          vars:
            default_sc: "{{ r_storageclasses.resources | json_query(query_sc) }}"
            query_sc: "[?metadata.annotations.\"storageclass.kubernetes.io/is-default-class\" == 'true'].metadata.name"

        - name: Abort if no default storage class found
          when: _ocp4_workload_openshift_virtualization_default_storage_class | length == 0
          ansible.builtin.fail:
            msg: "No default storage class found. Can not continue."

        - name: Print default storage class name
          ansible.builtin.debug:
            msg: "Default storage class: {{ _ocp4_workload_openshift_virtualization_default_storage_class }}"

        - name: Patch the storage profile matching the default storage class to use pvc instead of snapshot
          kubernetes.core.k8s:
            state: patched
            api_version: cdi.kubevirt.io/v1beta1
            kind: StorageProfile
            name: "{{ _ocp4_workload_openshift_virtualization_default_storage_class }}"
            definition:
              spec:
                dataImportCronSourceFormat: pvc

        - name: If we are using Hosted Control Planes, it is needed to set default accessMode, volumeMode and cloneStrategy
          when: _ocp4_workload_openshift_virtualization_default_storage_class == "kubevirt-csi-infra-default"
          kubernetes.core.k8s:
            state: patched
            api_version: cdi.kubevirt.io/v1beta1
            kind: StorageProfile
            name: "{{ _ocp4_workload_openshift_virtualization_default_storage_class }}"
            definition:
              spec:
                claimPropertySets:
                - accessModes:
                  - ReadWriteMany
                  volumeMode: Block
                cloneStrategy: copy

        - name: Finally patch HyperConverged to import boot sources now using PVCs
          kubernetes.core.k8s:
            state: patched
            api_version: hco.kubevirt.io/v1beta1
            kind: HyperConverged
            name: kubevirt-hyperconverged
            namespace: openshift-cnv
            definition:
              spec:
                featureGates:
                  enableCommonBootImageImport: true

      - name: Install virtctl to bastion VM
        when: ocp4_workload_openshift_virtualization_install_virtctl | bool
        block:
        - name: Get virtctl-clidownloads-kubevirt-hyperconverged ConsoleCLIDownload
          kubernetes.core.k8s_info:
            api_version: console.openshift.io/v1
            kind: ConsoleCLIDownload
            name: virtctl-clidownloads-kubevirt-hyperconverged
          register: r_virtctl_cli_download
          retries: 20
          delay: 10
          ignore_errors: true
          until:
          - r_virtctl_cli_download.resources is defined
          - r_virtctl_cli_download.resources | length > 0

        - name: Get virtctl download URL from ConsoleCLIDownload
          when: r_virtctl_cli_download.resources | length > 0
          ansible.builtin.set_fact:
            _ocp4_workload_openshift_virtualization_virtctl_url: >-
              {{ r_virtctl_cli_download.resources[0] | to_json | from_json
              | json_query("spec.links[?contains(href,'linux')].href") | first }}

        - name: Download virtctl cli tool
          ansible.builtin.get_url:
            url: "{{ _ocp4_workload_openshift_virtualization_virtctl_url }}"
            validate_certs: false
            dest: /tmp/virtctl.tar.gz
            mode: "0660"
          register: r_virtctl
          until: r_virtctl is success
          retries: 20
          delay: 10

        - name: Install virtctl CLI on bastion
          become: true
          ansible.builtin.unarchive:
            src: /tmp/virtctl.tar.gz
            remote_src: true
            dest: /usr/bin
            mode: "0775"
            owner: root
            group: root
          args:
            creates: /usr/bin/virtctl

        - name: Remove downloaded file
          ansible.builtin.file:
            state: absent
            path: /tmp/virtctl.tar.gz


  rescue:
    - name: "DIAG - POST-FAILURE state for ocp4_workload_openshift_virtualization"
      shell: |
        echo "====================================================================="
        echo "WORKLOAD FAILED: ocp4_workload_openshift_virtualization"
        echo "====================================================================="
        echo ""
        echo "=== NODE USAGE AT FAILURE ==="
        oc adm top nodes 2>/dev/null || echo "Metrics not available"
        echo ""
        echo "=== PODS BY PHASE ==="
        echo "Running: $(oc get pods -A --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)"
        echo "Pending: $(oc get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l)"
        echo "Failed: $(oc get pods -A --field-selector=status.phase=Failed --no-headers 2>/dev/null | wc -l)"
        echo "Total: $(oc get pods -A --no-headers 2>/dev/null | wc -l)"
        echo ""
        echo "=== PENDING PODS ==="
        oc get pods -A --field-selector=status.phase=Pending -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name --no-headers 2>/dev/null | head -20 || echo "None"
        echo ""
        echo "=== CSVs NOT SUCCEEDED ==="
        oc get csv -A --no-headers 2>/dev/null | grep -v Succeeded | head -20 || echo "All succeeded"
        echo ""
        echo "=== PENDING PVCs ==="
        oc get pvc -A --field-selector=status.phase!=Bound --no-headers 2>/dev/null | head -10 || echo "All bound"
        echo ""
        echo "=== FAILEDSCHEDULING EVENTS ==="
        oc get events -A --field-selector reason=FailedScheduling --no-headers 2>/dev/null | tail -10 || echo "None"
        echo ""
        echo "=== IMAGE PULL ERRORS ==="
        oc get events -A --field-selector reason=Failed --no-headers 2>/dev/null | grep -i "pull\|image\|registry" | tail -10 || echo "None"
        echo ""
        echo "=== RECENT WARNINGS (last 20) ==="
        oc get events -A --field-selector type=Warning --sort-by='.lastTimestamp' --no-headers 2>/dev/null | tail -20 || echo "None"
      register: diag_post_failure
      ignore_errors: true

    - name: "DIAG - Display post-failure state"
      debug:
        msg: "{{ diag_post_failure.stdout_lines | default(['no output']) }}"
      when: diag_post_failure is defined
      ignore_errors: true

    - name: Fail with original error
      fail:
        msg: "Workload ocp4_workload_openshift_virtualization failed. See diagnostics above."
